The project is organized into distinct modules, each focused on a specific part of the game logic. The main.py file serves as the entry point, orchestrating the game’s flow by tying together the various systems, including character creation, inventory management, combat, and quests. The character_manager.py module handles the creation and management of player characters, with each character's stats, class, and level being initialized and updated here. Inventory management is separated into the inventory_system.py, which governs the addition, removal, and usage of items during gameplay. The quest_handler.py module manages all aspects of quests, from assignment to completion, while the combat_system.py module handles the turn-based combat mechanics, ensuring a smooth encounter experience. Game data, including items and quests, is loaded from external files via game_data.py, isolating game content from the logic and making it easier to update or expand. Finally, custom_exceptions.py defines the custom exceptions, allowing for a standardized way to handle errors across the game. This modular architecture improves maintainability, ensures that each component has a clear responsibility, and allows for easy extension of the game without affecting the underlying systems.

Exception Strategy

The game uses a well-defined exception strategy to ensure robustness and maintainability. Custom exceptions are defined in the custom_exceptions.py module to handle specific error conditions that may arise during gameplay. For example, if a player attempts to create a character with an invalid class, the InvalidCharacterClassError is raised. Similarly, attempting to load a corrupted game save file results in the SaveFileCorruptedError. Inventory errors, such as trying to equip an item that is not present in the character's inventory, are handled by raising the ItemNotFoundError. These custom exceptions ensure that any invalid actions or system failures are caught early, and appropriate feedback is provided to the player. This strategy helps maintain a clean, predictable game flow and allows for easier debugging by making error conditions explicit rather than relying on return codes or generic exceptions.

Design Choices

The design choices in this project are aimed at creating a modular, extensible, and user-friendly game. The decision to split functionality across multiple modules (e.g., character management, inventory system, quests, combat) adheres to the principle of separation of concerns, making the code more maintainable and easier to extend. By keeping each module focused on a specific responsibility, the game logic remains clean, and new features can be added with minimal disruption to existing code. The use of external data files for quests, items, and enemy definitions provides flexibility, allowing content to be modified without touching the game’s core logic. This also makes it easier to scale the game in the future, whether by adding new quests or expanding the inventory system. Additionally, raising custom exceptions for different error conditions makes error handling explicit, improving the game’s reliability and user experience. Overall, these design decisions are intended to create a solid foundation that supports future development while maintaining clarity and simplicity in the current game structure.

AI Usage

AI, specifically ChatGPT, was instrumental in the early stages of development, assisting with brainstorming and structuring the modules of the game. It helped in deciding which components were necessary (e.g., character management, inventory system, combat mechanics) and how best to organize them into separate files. AI also contributed to drafting error-handling strategies, suggesting appropriate custom exceptions to raise for various edge cases, such as invalid character creation or corrupted save files. Additionally, AI was used to generate function docstrings and comments, which helped improve code readability and maintainability. The guidance provided by AI ensured that the overall architecture adhered to best practices, and its support in refactoring and debugging made the development process smoother. It was also helpful in generating the initial README documentation and providing suggestions for testing strategies, contributing to the completeness and transparency of the project.

How to Play

To play the game, first clone the repository using the following command:

git clone https://github.com/Fall-2025-COMP163/project-3-cdmullins-art.git
cd project-3-cdmullins-art

Ensure you have Python installed (version 3.x). You can then run the game by executing:

python main.py

Upon launching, the game will prompt you to create a character by selecting a class (Warrior, Mage, Rogue, or Cleric). After character creation, you will be able to embark on quests, manage your inventory, and engage in combat with enemies. As you progress, you can complete quests, gain experience, and equip items that improve your character’s abilities. You may also save your progress as the game supports save/load functionality. If you wish to view your character’s status or inventory, there are commands built into the game that allow you to check your progress. Invalid commands or illegal actions will trigger exceptions and notify you of the error. To exit the game, simply follow the on-screen instructions for quitting or pressing the designated key. The game’s modular design allows for easy expansion of quests, items, and gameplay mechanics in future updates.

